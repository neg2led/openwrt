From 38aad44a809235bde0875d5ea19cf741d72731ac Mon Sep 17 00:00:00 2001
From: Andrew Powers-Holmes <andrew@omnom.net>
Date: Wed, 17 Nov 2021 17:55:45 +1100
Subject: [PATCH 1/1] MIPS: Octeon: Add driver for OCTEON PCI console.

Shows up as /dev/ttyPCIx.

Signed-off-by: Andrew Powers-Holmes <andrew@omnom.net>
---
 arch/mips/cavium-octeon/Makefile             |   1 +
 arch/mips/cavium-octeon/octeon-pci-console.c | 380 +++++++++++++++++++
 arch/mips/cavium-octeon/setup.c              |   7 +-
 arch/mips/include/asm/octeon/octeon.h        |   3 +
 4 files changed, 387 insertions(+), 4 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/octeon-pci-console.c

--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -11,6 +11,7 @@
 
 obj-y := cpu.o setup.o octeon-platform.o octeon-irq.o csrc-octeon.o
 obj-y += dma-octeon.o
+obj-y += octeon-pci-console.o
 obj-y += octeon-memcpy.o
 obj-y += executive/
 obj-y += crypto/
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -65,10 +65,6 @@ const bool octeon_should_swizzle_table[2
 };
 EXPORT_SYMBOL(octeon_should_swizzle_table);
 
-#ifdef CONFIG_PCI
-extern void pci_console_init(const char *arg);
-#endif
-
 static unsigned long long max_memory = ULLONG_MAX;
 static unsigned long long reserve_low_mem;
 
@@ -354,7 +350,7 @@ EXPORT_SYMBOL(octeon_get_io_clock_rate);
  *
  * @s:	    String to write
  */
-static void octeon_write_lcd(const char *s)
+void octeon_write_lcd(const char *s)
 {
 	if (octeon_bootinfo->led_display_base_addr) {
 		void __iomem *lcd_address =
@@ -929,6 +925,9 @@ void __init prom_init(void)
 
 	octeon_use_image_cmdline();
 
+	if (strstr(arcs_cmdline, "console=pci"))
+		octeon_pci_console_init(strstr(arcs_cmdline, "console=pci") + 8);
+
 	if (strstr(arcs_cmdline, "console=") == NULL) {
 		if (octeon_uart == 1)
 			strcat(arcs_cmdline, " console=ttyS1,115200");
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -363,4 +363,7 @@ extern struct semaphore octeon_bootbus_s
 
 struct irq_domain *octeon_irq_get_block_domain(int node, uint8_t block);
 
+void octeon_pci_console_init(const char *);
+extern void octeon_write_lcd(const char *s);
+
 #endif /* __ASM_OCTEON_OCTEON_H */
--- /dev/null
+++ b/arch/mips/cavium-octeon/octeon-pci-console.c
@@ -0,0 +1,400 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2006-2012 Cavium, Inc.
+ *
+ * octeon_pci_console uses a protocol for sending and receiving byte
+ * streams through in-memory ring buffers.  The typical use case is to
+ * have a pseudo-tty like driver/program running on a host machine that
+ * services the buffers via a PCI link.  This driver implements the
+ * client side of the protocol when the OCTEON SOC is in PCI target
+ * mode.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+
+#include <asm/octeon/octeon.h>
+
+#define OCTEON_PCI_CONSOLE_MAJOR_VERSION    1
+#define OCTEON_PCI_CONSOLE_MINOR_VERSION    0
+
+#define OCTEON_PCI_CONSOLE_BLOCK_NAME   "__pci_console"
+
+struct octeon_pci_console_rings {
+#ifdef __BIG_ENDIAN
+	u64 input_base_addr;
+	volatile u32 input_read_index;
+	volatile u32 input_write_index;
+	u64 output_base_addr;
+	volatile u32 output_read_index;
+	volatile u32 output_write_index;
+	u32 unused;
+	u32 buf_size;
+#else /* __LITTLE_ENDIAN */
+	u64 input_base_addr;
+	volatile u32 input_write_index;
+	volatile u32 input_read_index;
+
+	u64 output_base_addr;
+	volatile u32 output_write_index;
+	volatile u32 output_read_index;
+
+	u32 buf_size;
+	u32 unused;
+#endif
+};
+
+struct octeon_pci_console_desc {
+#ifdef __BIG_ENDIAN
+	u32 major_version;
+	u32 minor_version;
+	u32 lock;
+	u32 flags;
+	u32 num_consoles;
+	u32 pad;
+#else /* __LITTLE_ENDIAN */
+	u32 minor_version;
+	u32 major_version;
+
+	u32 flags;
+	u32 lock;
+
+	u32 pad;
+	u32 num_consoles;
+#endif
+	/* Array of addresses of struct octeon_pci_console_rings structures */
+	uint64_t console_addr_array[0];
+	/* Implicit storage for console_addr_array */
+};
+
+struct octeon_pci_console {
+	struct console con;
+	struct tty_driver *ttydrv;
+	spinlock_t lock;
+	struct octeon_pci_console_rings *rings;
+	/* Pointers to the ring memory referred to in rings. */
+	u8 *input_ring;
+	u8 *output_ring;
+	struct timer_list poll_timer;
+	int open_count;
+	int index;
+	struct tty_port tty_port;
+};
+
+static struct octeon_pci_console octeon_pci_console;
+
+#ifdef __BIG_ENDIAN
+#define copy_to_ring memcpy
+#else /* __LITTLE_ENDIAN */
+/* console buffers are scrambled for __LITTLE_ENDIAN */
+static void copy_to_ring(u8 *dst, const u8 *src, unsigned int n)
+{
+	while (n) {
+		u8 *pd = (u8 *)((unsigned long)dst ^ 7);
+		*pd = *src;
+		n--;
+		dst++;
+		src++;
+	}
+}
+#endif
+
+/*
+ * Write all the data, possibly spinning waiting for the reader to
+ * free buffer space.
+ */
+static void octeon_pci_console_lowlevel_write(struct octeon_pci_console *opc,
+					      const char *str, unsigned int len)
+{
+	u32 s = opc->rings->buf_size;
+
+	spin_lock(&opc->lock);
+	while (len > 0) {
+		u32 r =  opc->rings->output_read_index;
+		u32 w =  opc->rings->output_write_index;
+		u32 a = ((s - 1) - (w - r)) % s;
+		unsigned int n;
+
+		if (!a)
+			continue;
+		if (r <= w)
+			n = min(a, min(len, s - w));
+		else
+			n = min(a, min(len, r - w));
+
+		copy_to_ring(opc->output_ring + w, str, n);
+		len -= n;
+		str += n;
+		w = (w + n) % s;
+		wmb();
+		opc->rings->output_write_index = w;
+		wmb();
+	}
+	spin_unlock(&opc->lock);
+}
+
+static void octeon_pci_console_write(struct console *con, const char *str,
+				     unsigned int len)
+{
+	octeon_pci_console_lowlevel_write(con->data, str, len);
+}
+
+static struct tty_driver *octeon_pci_console_device(struct console *con,
+						    int *index)
+{
+	struct octeon_pci_console  *opc = con->data;
+
+	*index = 0;
+	return opc->ttydrv;
+}
+
+static int octeon_pci_console_setup0(struct octeon_pci_console *opc)
+{
+	struct octeon_pci_console_desc *opcd;
+
+	if (!opc->rings) {
+		const struct cvmx_bootmem_named_block_desc *block_desc =
+			cvmx_bootmem_find_named_block(OCTEON_PCI_CONSOLE_BLOCK_NAME);
+		if (block_desc == NULL || block_desc->base_addr == 0)
+			goto fail;
+
+		opcd = phys_to_virt(block_desc->base_addr);
+		/*
+		 * We only work with version 1.0 of the protocol (the
+		 * only one that exists).
+		 */
+		if (opcd->major_version != 1 || opcd->minor_version != 0)
+			goto fail;
+
+		if (opcd->console_addr_array[opc->index])
+			opc->rings = phys_to_virt(opcd->console_addr_array[opc->index]);
+		else
+			goto fail;
+		spin_lock_init(&octeon_pci_console.lock);
+		opc->input_ring = phys_to_virt(opc->rings->input_base_addr);
+		opc->output_ring = phys_to_virt(opc->rings->output_base_addr);
+	}
+	return 0;
+fail:
+	return -1;
+}
+
+static int octeon_pci_console_setup(struct console *con, char *arg)
+{
+	struct octeon_pci_console *opc = con->data;
+
+	octeon_write_lcd("pci cons");
+	if (octeon_pci_console_setup0(opc)) {
+		octeon_write_lcd("pci fail");
+		return -1;
+	}
+	return 0;
+}
+
+void octeon_pci_console_init(const char *arg)
+{
+	struct octeon_pci_console *c = &octeon_pci_console;
+
+	memset(c, 0, sizeof(*c));
+	strcpy(c->con.name, "pci");
+	c->con.write = octeon_pci_console_write;
+	c->con.device = octeon_pci_console_device;
+	c->con.setup = octeon_pci_console_setup;
+	c->con.data = &octeon_pci_console;
+	if (arg && (arg[3] >= '0') && (arg[3] <= '9'))
+		sscanf(arg + 3, "%d", &c->index);
+	else
+		c->index = 0;
+	register_console(&c->con);
+}
+
+/*
+ * called by a timer to poll the PCI device for input data
+ */
+static void octeon_pci_console_read_poll(struct timer_list * arg)
+{
+	struct octeon_pci_console *opc = from_timer(opc, arg, poll_timer);
+	struct tty_struct *tty = opc->tty_port.tty;
+	int nr;
+	u32 s = opc->rings->buf_size;
+	u32 r = opc->rings->input_read_index;
+	u32 w = opc->rings->input_write_index;
+	u32 a = (w - r) % s;
+#ifdef __LITTLE_ENDIAN
+	int i;
+	u8 buffer[32];
+#endif
+
+	while (a > 0) {
+		u8 *buf;
+		unsigned int n;
+
+		if (r > w)
+			n = min(a, s - r);
+		else
+			n = min(a, w - r);
+#ifdef __LITTLE_ENDIAN
+		n = min_t(unsigned int, n, sizeof(buffer));
+		for (i = 0; i < n; i++) {
+			u8 *ps = (u8 *)((unsigned long)(opc->input_ring + r + i) ^ 7);
+			buffer[i] = *ps;
+		}
+		buf = buffer;
+#else /*  __BIG_ENDIAN */
+		buf = opc->input_ring + r;
+#endif
+		nr = tty_insert_flip_string(tty->port, buf, n);
+		if (!nr)
+			break;
+		r = (r + nr) % s;
+		a -= nr;
+		tty_flip_buffer_push(tty->port);
+	}
+	opc->rings->input_read_index = r;
+	wmb();
+
+	mod_timer(&opc->poll_timer, jiffies + 1);
+}
+
+static int octeon_pci_console_tty_open(struct tty_struct *tty,
+				       struct file *filp)
+{
+	struct octeon_pci_console  *opc = tty->driver->driver_state;
+
+	opc->open_count++;
+	if (opc->open_count == 1) {
+		timer_setup(&opc->poll_timer, octeon_pci_console_read_poll, 0);
+		mod_timer(&opc->poll_timer, jiffies + 1);
+	}
+	return 0;
+}
+
+static void octeon_pci_console_tty_close(struct tty_struct *tty,
+					 struct file *filp)
+{
+	struct octeon_pci_console  *opc = tty->driver->driver_state;
+
+	opc->open_count--;
+	if (opc->open_count == 0)
+		del_timer(&opc->poll_timer);
+}
+
+static int octeon_pci_console_tty_write(struct tty_struct *tty,
+					const unsigned char *buf,
+					int count)
+{
+	struct octeon_pci_console  *opc = tty->driver->driver_state;
+
+	octeon_pci_console_lowlevel_write(opc, buf, count);
+	return count;
+}
+
+static void octeon_pci_console_tty_send_xchar(struct tty_struct *tty, char ch)
+{
+	struct octeon_pci_console  *opc = tty->driver->driver_state;
+
+	octeon_pci_console_lowlevel_write(opc, &ch, 1);
+}
+
+/*
+ * Room available for output.  Assume maximum buffer size is
+ * available, we will spin if it is not.
+ */
+static int octeon_pci_console_tty_write_room(struct tty_struct *tty)
+{
+	struct octeon_pci_console  *opc = tty->driver->driver_state;
+
+	return opc->rings->buf_size - 1;
+}
+
+static int octeon_pci_console_tty_chars_in_buffer(struct tty_struct *tty)
+{
+	return 0;
+}
+
+static const struct tty_operations octeon_pci_tty_ops = {
+	.open = octeon_pci_console_tty_open,
+	.close = octeon_pci_console_tty_close,
+	.write = octeon_pci_console_tty_write,
+	.write_room = octeon_pci_console_tty_write_room,
+	.send_xchar = octeon_pci_console_tty_send_xchar,
+	.chars_in_buffer = octeon_pci_console_tty_chars_in_buffer,
+};
+
+static const struct tty_port_operations octeon_pci_port_ops;
+
+static int __init octeon_pci_console_module_init(void)
+{
+	int ret;
+	struct tty_driver *d;
+
+	d = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);
+	if (IS_ERR(d))
+		return PTR_ERR(d);
+
+	if (octeon_pci_console_setup0(&octeon_pci_console)) {
+		pr_notice("Console not created.\n");
+		ret = -ENODEV;
+		goto err;
+	} else {
+		pr_info("Initialized.\n");
+	}
+	tty_port_init(&octeon_pci_console.tty_port);
+	octeon_pci_console.tty_port.ops = &octeon_pci_port_ops;
+
+	d->owner = THIS_MODULE;
+	d->driver_name = "octeon_pci_console";
+	d->name = "ttyPCI";
+	d->type = TTY_DRIVER_TYPE_SERIAL;
+	d->subtype = SERIAL_TYPE_NORMAL;
+	d->major = 4;
+	d->minor_start = 96;
+	d->init_termios = tty_std_termios;
+	d->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	d->driver_state = &octeon_pci_console;
+	tty_set_operations(d, &octeon_pci_tty_ops);
+	tty_port_link_device(&octeon_pci_console.tty_port, d, 0);
+
+	ret = tty_register_driver(d);
+	if (ret < 0) {
+		pr_err("Couldn't register octeon_pci_console driver\n");
+		goto err;
+	}
+
+	octeon_pci_console.ttydrv = d;
+	return 0;
+
+err:
+	put_tty_driver(d);
+	tty_port_destroy(&octeon_pci_console.tty_port);
+	return ret;
+}
+
+static void __exit octeon_pci_console_module_exit(void)
+{
+	unregister_console(&octeon_pci_console.con);
+	tty_unregister_driver(octeon_pci_console.ttydrv);
+	put_tty_driver(octeon_pci_console.ttydrv);
+	tty_port_destroy(&octeon_pci_console.tty_port);
+}
+
+module_init(octeon_pci_console_module_init);
+module_exit(octeon_pci_console_module_exit);
+
+MODULE_LICENSE("GPL");
